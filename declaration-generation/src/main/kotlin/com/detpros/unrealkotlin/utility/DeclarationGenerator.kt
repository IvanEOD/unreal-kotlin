package com.detpros.unrealkotlin.utility


/**
 *  Declarations Generator
 *
 * @author IvanEOD ( 5/23/2023 at 2:39 PM EST )
 */


fun kotlinUE5Text() = """// Generated by Detonate Productions Declaration Generation, do not edit manually!
@file:Suppress(
    "INTERFACE_WITH_SUPERCLASS",
    "OVERRIDING_FINAL_MEMBER",
    "RETURN_TYPE_MISMATCH_ON_OVERRIDE",
    "CONFLICTING_OVERLOADS",
)

package ue

external class UClass {}

external interface KotlinUnrealObject {
    @JsName("Tick")
    fun tick(deltaTime: Float)
    @JsName("BeginOverlap")
    fun beginOverlap(other: Actor): String
    @JsName("EndOverlap")
    fun endOverlap(other: Actor)
    @JsName("OnDestroyed")
    fun onDestroyed()
}

external class KotlinActorComponent : ActorComponent {
    @JsName("Spawn")
    fun <T : Actor> spawn(actorClass: UClass, position: Vector, rotation: Rotator): T
}

open external class KotlinObject : KotlinUnrealObject {
    val root: KotlinActorComponent
    override fun tick(deltaTime: Float)
    override fun beginOverlap(other: Actor): String = definedExternally
    override fun endOverlap(other: Actor)
    override fun onDestroyed()
}

fun <T : Actor> KotlinObject.getOwner(): T = root.getOwner().asDynamic() as T

external var global: dynamic
external var ComponentRoot: dynamic

private object KotlinUnrealClassCache {
    val cache = mutableMapOf<String, dynamic>()
}

@JsName("unrealProxyClass")
fun unrealProxyClass(global: dynamic, klass: dynamic, className: String) {
    val GeneratedClassDefinition = if (KotlinUnrealClassCache.cache.containsKey(className))
        KotlinUnrealClassCache.cache[className]
    else {
        val value = js("require('uklass')()(global, klass)")
        KotlinUnrealClassCache.cache[className] = value
        value
    }
    val instance = js("new GeneratedClassDefinition()")
    instance.Root = ComponentRoot
    instance.Root.SetKotlinObject(instance)
    instance.konstructor()
    if (!global.precious) global.precious = js("[]"); global.precious.push(instance)
}

fun Vector(
    x: Number = 0,
    y: Number = 0,
    z: Number = 0,
) = ue.Vector().apply {
    this.x = x.toDouble()
    this.y = y.toDouble()
    this.z = z.toDouble()
}

fun Rotator(
    roll: Number = 0,
    pitch: Number = 0,
    yaw: Number = 0,
): Rotator = ue.Rotator().apply {
    this.roll = roll.toDouble()
    this.pitch = pitch.toDouble()
    this.yaw = yaw.toDouble()
}

fun LinearColor(r: Number = 0, g: Number = 0, b: Number = 0, a: Number = 1) = ue.LinearColor().apply {
    this.r = r.toDouble()
    this.g = g.toDouble()
    this.b = b.toDouble()
    this.a = a.toDouble()
}

inline fun Vector.withX(x: Number) = this.apply { this.x = x.toDouble() }
inline fun Vector.withY(y: Number) = this.apply { this.y = y.toDouble() }
inline fun Vector.withZ(z: Number) = this.apply { this.z = z.toDouble() }

inline fun Rotator.withRoll(roll: Number) = this.apply { this.roll = roll.toDouble() }
inline fun Rotator.withPitch(pitch: Number) = this.apply { this.pitch = pitch.toDouble() }
inline fun Rotator.withYaw(yaw: Number) = this.apply { this.yaw = yaw.toDouble() }

fun <T> Blueprint.generateClass(world: World, position: Vector, rotation: Rotator): T {
    val receiver = this
    return js("new receiver.generatedClass(world, position, rotation)").unsafeCast<T>()
}

fun <T> MovieSceneSpawnable.generateClass(world: World, position: Vector, rotation: Rotator): T {
    val receiver = this
    return js("new receiver.generatedClass(world, position, rotation)").unsafeCast<T>()
}

fun <T> Actor.getComponentByName(componentClass: Any, name: String): T {
    val nameToCheck = name.lowercase()
    val components = getComponentsByClass(componentClass).filter { it.getName().lowercase() == nameToCheck }
    if (components.isEmpty()) return null as T
    return components.first().asDynamic().unsafeCast<T>()
}

fun <T> Actor.getComponentByClass(componentClass: Any): T = getComponentByClass(componentClass).asDynamic().unsafeCast<T>()
fun <T> Actor.getComponentsByClass(componentClass: Any): Array<T> = getComponentsByClass(componentClass).asDynamic().unsafeCast<Array<T>>()

fun Key(keyName: String): Key = Key().apply { this.keyName = keyName }

class KeyListener(keyName: String, private val playerControllerIndex: Int = 0) {
    private val k = Key(keyName)
    fun down(): Boolean = GWorld.getPlayerController(playerControllerIndex).isInputKeyDown(k)
    fun pressed(): Boolean = GWorld.getPlayerController(playerControllerIndex).wasInputKeyJustPressed(k)
    fun released(): Boolean = GWorld.getPlayerController(playerControllerIndex).wasInputKeyJustReleased(k)
}

""".trimIndent()